from dataclasses import dataclass
import math
import os
from typing import Optional, Tuple, List

from ase import Atoms, Atom
from ase.build import fcc110
import numpy as np
import torch

from calc import Calculator
from ga import GA
from surface_env import MCTEnv

@dataclass
class ASOP():
    initial_slab: Atoms                             # The target system
    metal_ele: str = 'Ag'
    # Calculator parameters
    calculator_method: str = 'LASP'                 # in ['LASP', 'MACE']
    model_path: str = 'AgO'                         # Your machine learning model
    # Thermal condition parameters
    T: float =  473.15                              #/K
    P: float = 0.2                                  #/bar
    # Genetic Algorithm parameters
    db_path: str = 'gadb.db'                        # Data base for GA
    traj_path: str = 'candidates.traj'              # Candidates generated by GA

    def __post_init__(self) -> None:
        self.env = MCTEnv(reaction_H =0.790, reaction_n = 8, delta_s = 0.414,
                          calculator_method = self.calculator_method, model_path = self.model_path, 
                          initial_slab = self.initial_slab, metal_ele = self.metal_ele)
        self.calculator = Calculator(calculate_method = self.calculator_method,
                                     model_path = self.model_path)
    
    def run(self) -> List:
        miu_list = [0.0]
        structure_list = [self.pd(self.initial_slab)]

        for n_Ag in range(self.A):
            for n_O in range(self.A):
                n_Ag += 1
                n_O += 1

                atoms = self.choose_ads_site(atoms, n_Ag, n_O)
                E_miu, current_structure = self.get_miu(atoms)
                
                miu_list.append(E_miu)
                structure_list.append(current_structure)

        self.save_atoms(miu_list, structure_list)

        return miu_list

    def save_atoms(self, miu_list:List, structure_list:List) -> None:
        save_path = os.path.join('./', f"{'asop'}.npz")
        np.savez_compressed(
            save_path,
            miu = miu_list,
            structures = structure_list,
        )

    def get_miu(self, atoms:Atoms) -> Tuple[float, np.asarray]:
        new_state = atoms.copy()

        self.env.to_constraint(new_state)
        new_state, current_energy, _ = self.calculator(new_state, calc_type = 'ssw')

        E_miu = self.miu(current_energy)
        structure = self.pd(new_state)

        return E_miu, structure

    @property
    def matrix_list(self):
        matrix_list = np.array([])
        
        return matrix_list
    
    @property
    def A(self) -> int:
        return len(self.env.get_sub_list(self.initial_slab))
    
    def add_mole(self, mole:str, d:Optional[float]) -> float:
        new_state = self.initial_slab.copy()
        energy_1 = self.calculator_method(new_state, calc_type = 'single')
        if len(mole) == 1:
            ele = Atom(mole, (new_state.get_cell()[0][0] / 2, 
                              new_state.get_cell()[1][1] / 2, 
                              new_state.get_cell()[2][2] - 5.0))
            new_state += ele
        if len(mole) == 2:
            ele_1 = Atom(mole[0], (new_state.get_cell()[0][0] / 2,
                                   new_state.get_cell()[1][1] / 2, 
                                   new_state.get_cell()[2][2] - 5.0))
            ele_2 = Atom(mole[1], (new_state.get_cell()[0][0] / 2, 
                                   new_state.get_cell()[1][1] / 2, 
                                   new_state.get_cell()[2][2] - 5.0 + d))
            new_state += ele_1
            new_state += ele_2
        energy_2 = self.calculator_method(new_state, calc_type = 'single')
        energy = energy_2 - energy_1
        return energy
    
    @property
    def E_O2(self) -> float:
        return self.add_mole(mole = 'OO', d = 1.21)
    
    @property
    def E_Ag(self) -> float:
        return self.add_mole(mole = 'Ag')
    
    @property
    def initial_energy(self) -> float:
        self.env.to_constraint(self.initial_slab)
        _, initial_energy, _ = self.calculator(self.initial_slab)
        return initial_energy
    
    def pd(self, atoms:Atoms) -> np.asarray:
        pad =  torch.nn.ZeroPad2d(padding = (0,0,0, 200 - len(atoms.get_positions())))
        return np.array(pad(torch.tensor(atoms.get_positions())))
    
    def miu(self, current_energy:float, n_Ag: int, n_O: int, A:int) -> float:
        current_energy -= self.E_Ag * n_Ag + self.n_O2 * n_O / 2
        miu = (current_energy - self.initial_energy) / A
        return miu

if __name__ == '__main__':
    initial_slab = fcc110('Ag', size=(2, 2, 3), vacuum=10.0)

    asop = ASOP(initial_slab)

    energy_list = asop.run()

    print(energy_list)