from dataclasses import dataclass
import os
from typing import Optional, Tuple, List, Dict

from ase import Atoms, Atom
from ase.build import fcc110
import numpy as np
from numpy.linalg import norm
import torch

from calc import Calculator
from ga import GA
from surface_env import MCTEnv

@dataclass
class ASOP():
    initial_slab: Atoms                             # The target system
    mock_slab:Atoms
    metal_ele: str = 'Ag'
    # Calculator parameters
    calculator_method: str = 'LASP'                 # in ['LASP', 'MACE']
    model_path: str = 'AgO'                         # Your machine learning model
    # Thermal condition parameters
    T: float =  473.15                              #/K
    P: float = 0.2                                  #/bar
    # ASOP Start and termination grids
    start_A: float = 4
    end_A: float = 12
    # Genetic Algorithm parameters
    db_file: str = './save_dir/db'                        # Data base for GA
    traj_file: str = './save_dir/traj'              # Candidates generated by GA

    def __post_init__(self) -> None:
        self.env = MCTEnv(reaction_H =0.790, reaction_n = 8, delta_s = 0.414,
                          calculator_method = self.calculator_method, model_path = self.model_path, 
                          initial_slab = self.initial_slab, metal_ele = self.metal_ele)
        self.calculator = Calculator(calculate_method = self.calculator_method,
                                     model_path = self.model_path)
        if self.calculator_method in ['MACE', 'Mace', 'mace']:
            if not os.path.exists(self.db_file):
                os.mkdir(self.db_file)
            if not os.path.exists(self.traj_file):
                os.mkdir(self.traj_file)
    
    def run(self) -> None:
        # The main modules of ASOP
        # 1. Generation of possible supercell
        # 2. Using GO methods + MLP potentials to generate global minimum
        # 3. Favorable composition determination by Monte Carlo selection
        history = {}
        results = ['Ag', 'O', 'structures', 'miu']
        for item in results:
            history[item] = []
        primitive_cell = self.mock_slab.cell

        # Step 1: Generate possible supercell
        possible_A, possible_grids, A_list = self.possible_grids()

        # Step 2: Structure exploration for compositions in a grid
        for grid_index in range(len(possible_grids)):
            atoms = self.initial_slab.copy()
            A_matrix_2D = possible_A[grid_index]
            A_matrix = np.array([[A_matrix_2D[0][0], A_matrix_2D[0][1], 0],
                                 [A_matrix_2D[1][0], A_matrix_2D[1][1], 0],
                                 [0                , 0                , 1]])

            atoms.set_cell(A_matrix * primitive_cell)
            self.in_cell(atoms)
            
            # num of atoms
            A = np.cross(A_matrix_2D[0], A_matrix_2D[1])
            for n_Ag in range(A):
                for n_O in range(A):
                    n_Ag += 1
                    n_O += 1

                    # Stage A: Initial structure generation
                    if self.calculator_method in ['LASP', 'Lasp', 'lasp']:
                        atoms = self.choose_ads_site(atoms, n_Ag, n_O)
                    else:
                        ga = GA(calculator_method = self.calculator_method,
                                model_path = self.model_path,
                                db_file = f'{self.db_file}/{norm(A_matrix_2D[0])}x{norm(A_matrix_2D[1])}_Ag{n_Ag}O{n_O}.db',
                                traj_path = f'{self.traj_file}/{norm(A_matrix_2D[0])}x{norm(A_matrix_2D[1])}_Ag{n_Ag}O{n_O}.traj')
                        atom_numbers = n_Ag * [47] + n_O * [8]
                        atoms = ga(atoms, atom_numbers)

                    # stage B-D
                    E_miu, current_structure = self.get_miu(atoms)
                    
                    history['miu'].append(E_miu)
                    history['structure'].append(current_structure)
                    history['Ag'].append(n_Ag)
                    history['O'].append(n_O)

        self.save_atoms(history, 
                        possible_A, 
                        possible_grids,
                        A_list)


    def save_atoms(self, 
                   history:Dict, 
                   possible_A: np.asarray, 
                   possible_grids: np.asarray,
                   A_list: List) -> None:
        save_path = os.path.join('./', f"{'asop'}.npz")
        np.savez_compressed(
            save_path,
            miu = history['miu'],
            structures = history['structure'],
            Ag = history['Ag'],
            O = history['O'],
            A_matrix = possible_A,
            A = A_list,
            grids = possible_grids,
        )

    def get_miu(self, atoms:Atoms) -> Tuple[float, np.asarray]:
        new_state = atoms.copy()

        self.env.to_constraint(new_state)
        # Stage B: SSW global structure search
        # Stage C: Self-learning of G-NN potential(Suspending)
        new_state, current_energy, _ = self.calculator(new_state, calc_type = 'ssw')
        
        # Stage D: Thermodynamics stability evaluation.
        E_miu = self.miu(current_energy)
        structure = self.pd(new_state)

        return E_miu, structure
    

    def in_cell(self, atoms:Atoms) -> None:
        # A function just like material studio "in cell" display
        cell = atoms.cell
        scaled_positions = cell.scaled_positions(atoms.positions)
        atoms.set_scaled_positions(scaled_positions)
        del atoms[[[atom_idx for atom_idx in range(len(atoms)) \
                    if max(scaled_positions[atom_idx]) >= 1]]]

    def possible_grids(self) -> Tuple[np.asarray, np.asarray]:
        # for fcc110 [u, v] = [√6/3, 0]
        #                     [0, √3/3]
        uv = np.array([[np.sqrt(2/3), 0],
                        [0, np.sqrt(1/3)]])
        
        possible_hk = []
        possible_grids = []
        A_list = []

        # depending on Niggli reduced cell theory
        # may have any other elegant code
        total_h = []
        for h1 in range(21):
            for h2 in range(21):
                total_h.append(np.array([h1-10, h2-10]))
        total_h = np.array(total_h)
        total_k = total_h

        # Start to find possible (h,k)
        for h in total_h:
            for k in total_k:
                p_hk = np.array([h,k])

                # Filter 1: All A: (h,k) must be positive
                if not np.all(np.linalg.eigvals(p_hk + p_hk.T)> 0):
                    continue

                # Filter 2: |h x k| ∈ [4,16]
                # target system range from (2x2) to (4x4)
                mo_hk = np.cross(h, k)
                if mo_hk < self.start_A or mo_hk > self.end_A:
                    continue

                # generate u', v'
                uv_dot = np.dot(p_hk, uv)
                u_dot, v_dot = uv_dot

                # Filter 3: |u'| >= |v'| and |u'| < 3|v'|
                # |u'| >= |v'| reduce computational costs
                # 3|u'| < |v'| filters too narrow supercell
                if norm(u_dot) < norm(v_dot) or norm(u_dot) >= 3 * norm(v_dot):
                    continue
                
                # Filter 4: angle between u', v' ∈ [60°, 90°]
                # kept as the valid/non-redundant supercell candidate
                cos_theta = np.dot(u_dot,v_dot)/(norm(u_dot)*norm(v_dot))
                if cos_theta < 0 or cos_theta > 0.5:
                    continue
                
                A_list.append(mo_hk)
                possible_hk.append(p_hk)
                possible_grids.append(uv_dot)
        
        possible_hk, possible_grids = self.rearrange(possible_hk, possible_grids, A_list)
        return possible_hk, possible_grids, A_list
    
    def rearrange(self, 
                  possible_hk:List, 
                  possible_grids:List,
                  A_list:List) -> np.asarray:
        hk_list = []
        grid_list = []
        
        for target_A in range(self.end_A - self.start_A + 1):
            target_A += self.start_A
            for i in range(len(A_list)):
                A = A_list[i]
                if A == target_A:
                    hk_list.append(possible_hk[i])
                    grid_list.append(possible_grids[i])

        return np.array(hk_list), np.array(grid_list)

    def distance(self, x1: np.asarray, x2:np.asarray) -> float:
        return norm(x1 - x2)

    def empty_sites(self, atoms:Atoms, surf_atoms:List) -> np.asarray:
        surf_sites, _ = self.env.get_surf_sites(atoms)
        sub_sites, _ = self.env.get_sub_sites(atoms)

        empty_sites = []
        if surf_atoms is []:
            empty_sites = sub_sites
        else:
            for sub_site in sub_sites:
                for atom_idx in surf_atoms:
                    distance = self.distance(atoms.get_positions()[atom_idx], sub_site[0:3])
                    if distance >= 1.5 and distance <= 3.0:
                        empty_sites.append(sub_site)
                        break
            # All sub layer sites has been occupied
            if empty_sites is []:
                layer_atoms = self.env.get_layer_list(atoms)
                if layer_atoms:
                    for surf_site in surf_sites:
                        for atom_idx in layer_atoms:
                            distance = self.distance(atoms.get_positions()[atom_idx], surf_site[0:3])
                            if distance >= 1.5 and distance <= 3.0:
                                empty_sites.append(surf_site)
                                break
                else:
                    empty_sites = surf_sites
        return empty_sites

    def choose_ads_site(self,atoms:Atoms, n_Ag:int, n_O:int) -> Atoms:
        new_state = atoms.copy()
        for _ in range(n_Ag):
            surf_atoms = self.get_surf_list(new_state)
            empty_sites = self.empty_sites(new_state, surf_atoms)
            Ag_site = empty_sites[np.random.randint(len(empty_sites))]
            Ag = Atom('Ag', (Ag_site[0] + self.env.d_list[int(Ag_site[3]) - 1 ], 
                             Ag_site[1] + self.env.d_list[int(Ag_site[3]) - 1 ], 
                             Ag_site[2] + self.env.d_list[int(Ag_site[3]) - 1 ]))
            new_state += Ag

        for _ in range(n_O):
            surf_atoms = self.get_surf_list(new_state)
            empty_sites = self.empty_sites(new_state, surf_atoms)
            O_site = empty_sites[np.random.randint(len(empty_sites))]
            O = Atom('O', (O_site[0] + self.env.d_list[int(O_site[3]) - 1 ], 
                             O_site[1] + self.env.d_list[int(O_site[3]) - 1 ], 
                             O_site[2] + self.env.d_list[int(O_site[3]) - 1 ]))
            new_state += O
        return new_state
    
    def add_mole(self, mole:str, d:Optional[float]) -> float:
        new_state = self.initial_slab.copy()
        energy_1 = self.calculator_method(new_state, calc_type = 'single')
        if len(mole) == 1:
            ele = Atom(mole, (new_state.get_cell()[0][0] / 2, 
                              new_state.get_cell()[1][1] / 2, 
                              new_state.get_cell()[2][2] - 5.0))
            new_state += ele
        if len(mole) == 2:
            ele_1 = Atom(mole[0], (new_state.get_cell()[0][0] / 2,
                                   new_state.get_cell()[1][1] / 2, 
                                   new_state.get_cell()[2][2] - 5.0))
            ele_2 = Atom(mole[1], (new_state.get_cell()[0][0] / 2, 
                                   new_state.get_cell()[1][1] / 2, 
                                   new_state.get_cell()[2][2] - 5.0 + d))
            new_state += ele_1
            new_state += ele_2
        energy_2 = self.calculator_method(new_state, calc_type = 'single')
        energy = energy_2 - energy_1
        return energy
    
    @property
    def E_O2(self) -> float:
        return self.add_mole(mole = 'OO', d = 1.21)
    
    @property
    def E_Ag(self) -> float:
        return self.add_mole(mole = 'Ag')
    
    @property
    def initial_energy(self) -> float:
        self.env.to_constraint(self.initial_slab)
        _, initial_energy, _ = self.calculator(self.initial_slab)
        return initial_energy
    
    def pd(self, atoms:Atoms) -> np.asarray:
        pad =  torch.nn.ZeroPad2d(padding = (0,0,0, 200 - len(atoms.get_scaled_positions())))
        return np.array(pad(torch.tensor(atoms.get_positions())))
    
    def miu(self, current_energy:float, n_Ag: int, n_O: int, A:int) -> float:
        current_energy -= self.E_Ag * n_Ag + self.n_O2 * n_O / 2
        miu = (current_energy - self.initial_energy) / A
        return miu

if __name__ == '__main__':
    initial_slab = fcc110('Ag', size=(6, 6, 3), vacuum=10.0)
    mock_slab = fcc110('Ag', size = (1,1,3), vacuum = 10.0)
    asop = ASOP(initial_slab = initial_slab,
                mock_slab=mock_slab,
                calculator_method = 'MACE',
                model_path = 'AgO.model')
    asop.run()