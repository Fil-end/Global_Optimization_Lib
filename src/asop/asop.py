from dataclasses import dataclass
import logging
import os
from typing import Optional, Tuple, List, Dict
import timeout_decorator

from ase import Atoms, Atom
from ase.build import fcc110
from ase.data import covalent_radii
from ase.geometry import wrap_positions
from ase.io.dmol import write_dmol_arc
import numpy as np
from numpy.linalg import norm
import torch

from calc import Calculator
from ga import GA
from surface_env import MCTEnv

K = 8.617 * 10E-5
r_Ag = covalent_radii[47]
r_O = covalent_radii[8]

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

@dataclass
class ASOP():
    initial_slab: Atoms                             # The target system
    mock_slab:Atoms
    metal_ele: str = 'Ag'
    # Calculator parameters
    calculator_method: str = 'LASP'                 # in ['LASP', 'MACE']
    model_path: str = 'AgO'                         # Your machine learning model
    # Thermal condition parameters
    T: float =  473.15                              #/K
    P: float = 0.25                                  #/bar
    # ASOP Start and termination grids
    start_A: float = 13
    end_A: float = 13
    # Genetic Algorithm parameters
    db_file: str = './save_dir/db'                        # Data base for GA
    traj_file: str = './save_dir/traj'              # Candidates generated by GA

    def __post_init__(self) -> None:
        self.env = MCTEnv(reaction_H =0.790, reaction_n = 8, delta_s = 0.414,
                          calculator_method = self.calculator_method, model_path = self.model_path, 
                          metal_ele = self.metal_ele)
        self.calculator = Calculator(calculate_method = self.calculator_method,
                                     model_path = self.model_path)
        if self.calculator_method in ['MACE', 'Mace', 'mace']:
            if not os.path.exists(self.db_file):
                os.mkdir(self.db_file)
            if not os.path.exists(self.traj_file):
                os.mkdir(self.traj_file)
        
        self.E_O = (self.add_mole(mole = 'OO', d = 1.21) + K * self.T * np.log(self.P / 101325))/ 2
        self.E_Ag = self.calculator(self.mock_slab, calc_type = 'single') / len(self.mock_slab)
    
    def run(self) -> None:
        # The main modules of ASOP
        # 1. Generation of possible supercell
        # 2. Using GO methods + MLP potentials to generate global minimum
        # 3. Favorable composition determination by Monte Carlo selection
        history = {}
        results = ['Ag', 'O', 'structures', 'miu', 'TM', 'grids', 'A']
        for item in results:
            history[item] = []
        primitive_cell = self.mock_slab.cell

        # Step 1: Generate possible supercell
        possible_A, possible_grids, A_list = self.possible_grids()
        # Step 2: Structure exploration for compositions in a grid
        for grid_index in range(len(possible_grids)):
            grid_index = len(possible_grids) - grid_index - 1
            atoms = self.initial_slab.copy()
            # move the atoms to the center of the slab
            self.rectify_position(atoms)
            
            A_matrix_2D = possible_A[grid_index]
            grids = possible_grids[grid_index]
            A = A_list[grid_index]
            print(f"Logger Info: TM is {A_matrix_2D}", flush=True)
            A_matrix = np.array([[A_matrix_2D[0][0], A_matrix_2D[0][1], 0],
                                 [A_matrix_2D[1][0], A_matrix_2D[1][1], 0],
                                 [0                , 0                , 1]])
            atoms.set_cell(np.dot(A_matrix, primitive_cell))
            self.in_cell(atoms)
            
            if self.judge_structure(atoms):
                logger.warning(f"Logger Warning: {self.judge_structure(atoms)}")
                continue

            # calculate energy of clean surface
            try:
                atoms,initial_energy = self.initial_energy(atoms)
            except:
                logger.warning(f"Logger Warning: TM {A_matrix_2D} Failed")
                break
           
            A = np.cross(A_matrix_2D[0], A_matrix_2D[1])
            for n_Ag in range(A):
                n_Ag += 1
                for n_O in range(A): 
                    n_O += 1
                    new_state = atoms.copy()
                    u_p,v_p = A_matrix_2D
                    norm_u = np.round(norm(u_p), 3)
                    norm_v = np.round(norm(v_p), 3)
                    if not os.path.exists(f'./save_dir/{norm_u}x{norm_v}'):
                        os.mkdir(f'./save_dir/{norm_u}x{norm_v}')
                        
                    # Stage A: Initial structure generation
                    if self.calculator_method in ['LASP', 'Lasp', 'lasp']:
                        logger.info(f"Logger Info: Ag is {n_Ag}, O is {n_O}")
                        new_state = self.choose_ads_site(new_state, n_Ag, n_O)
                    else:
                        db_file = f'{self.db_file}/{norm_u}x{norm_v}_Ag{n_Ag}O{n_O}.db'
                        traj_path = f'{self.traj_file}/{norm_u}x{norm_v}_Ag{n_Ag}O{n_O}.traj'

                        if not os.path.exists(traj_path):
                            if os.path.exists(db_file):
                                os.remove(db_file)
                            ga = GA(calculator_method = self.calculator_method,
                                    model_path = self.model_path,
                                    db_file = db_file,
                                    traj_path = traj_path)
                            atom_numbers = n_Ag * [47] + n_O * [8]
                            try:
                                # new_state = self.choose_ads_site(new_state, n_Ag, n_O)
                                new_state = ga(new_state, atom_numbers)
                            except:
                                logger.warning(f'Logging Warning: TM is {A_matrix_2D}, Ag:{n_Ag}, O:{n_O}')
                                continue
                    
                    # stage B-C
                    try:
                        new_state, current_energy = self.get_energy(new_state)
                        new_state.pbc = True
                        write_dmol_arc(f'./save_dir/{norm_u}x{norm_v}/Ag{n_Ag}O{n_O}.arc', [new_state])
                        # Stage D: Thermodynamics stability evaluation.
                        E_miu = self.miu(current_energy, initial_energy, n_Ag, n_O,A)
                        
                        history['miu'].append(E_miu)
                        history['Ag'].append(n_Ag)
                        history['O'].append(n_O)
                        history['TM'].append(A_matrix_2D)
                        history['grids'].append(grids)
                        history['A'].append(A)
                    except:
                        logger.warning(f'Logging Warning: TM is {A_matrix_2D}, Ag:{n_Ag}, O:{n_O}')
                        break

            self.save_atoms(history)


    def save_atoms(self, 
                   history:Dict) -> None:
        save_path = os.path.join('./', f"{'asop'}.npz")
        np.savez_compressed(
            save_path,
            miu = history['miu'],
            Ag = history['Ag'],
            O = history['O'],
            A_matrix = history['TM'],
            A = history['A'],
            grids = history['grids'],
        )

    @timeout_decorator.timeout(600)
    def get_energy(self, atoms:Atoms) -> Tuple[float, np.asarray]:
        new_state = atoms.copy()

        self.env.to_constraint(new_state)
        # Stage B: SSW global structure search
        # Stage C: Self-learning of G-NN potential(Suspending)
        if self.calculator_method in ['LASP', 'Lasp', 'lasp']:
            new_state, current_energy = self.calculator(new_state, calc_type = 'ssw')
        elif self.calculator_method in ['MACE', 'Mace', 'mace']:
            new_state, current_energy, _ = self.calculator(new_state)
        
        # structure = self.pd(new_state)

        return new_state, current_energy
    
    def rectify_position(self, atoms:Atoms) -> None:
        positions = atoms.get_positions() - np.array([atoms.cell[0][0]/2, atoms.cell[1][1]/2, 0])
        atoms.positions = positions
        # Here the initial slab is a grand board
        atoms.set_pbc([False,False,False])

    def in_cell(self, atoms:Atoms) -> None:
        # A function just like material studio "in cell" display
        scaled_positions = atoms.get_scaled_positions()
        del atoms[[[atom_idx for atom_idx in range(len(atoms)) \
                    if max(scaled_positions[atom_idx]) >= 1 - 10E-3 or \
                       min(scaled_positions[atom_idx]) < -10E-3]]]
        atoms.set_pbc([True, True, False])

    def in_cell_sites(self,atoms:Atoms, site_type = 'surf') -> None:
        primitive_cell = atoms.cell
        atoms = atoms * (3,3,1)
        self.rectify_position(atoms)

        total_sites = []
        if site_type == 'surf':
            total_surf_sites, _ = self.env.get_surf_sites(atoms)
            for surf_site in total_surf_sites:
                w_p = wrap_positions([surf_site[0:3].tolist()], primitive_cell.tolist(), pbc=[1,1,0])
                if '%.2f' % surf_site[0] == '%.2f' % w_p.tolist()[0][0] and \
                    '%.2f' % surf_site[1] == '%.2f' % w_p.tolist()[0][1] and \
                    '%.2f' % surf_site[2] == '%.2f' % w_p.tolist()[0][2]:
                    total_sites.append(surf_site.tolist())

        elif site_type == 'sub':
            total_sub_sites, _ = self.env.get_sub_sites(atoms)
            for sub_site in total_sub_sites:
                w_p = wrap_positions([sub_site[0:3].tolist()], primitive_cell.tolist(), pbc=[1,1,0])
                if '%.2f' % sub_site[0] == '%.2f' % w_p.tolist()[0][0] and \
                    '%.2f' % sub_site[1] == '%.2f' % w_p.tolist()[0][1] and \
                    '%.2f' % sub_site[2] == '%.2f' % w_p.tolist()[0][2]:
                    total_sites.append(sub_site.tolist())

        total_sites = np.array([site for n,site in enumerate(total_sites) \
                                if site not in total_sites[:n] and site not in self.forbidden_site])
        return np.array(total_sites)
        

    def possible_grids(self) -> Tuple[np.asarray, np.asarray]:
        # for fcc110 [u, v] = [√6/3, 0]
        #                     [0, √3/3]
        uv = np.array([[np.sqrt(2/3), 0],
                        [0, np.sqrt(1/3)]])
        
        possible_hk = []
        possible_grids = []
        A_list = []
        norm_hk_list = []

        # depending on Niggli reduced cell theory
        # may have any other elegant code
        total_h = []
        for h1 in range(21):
            for h2 in range(21):
                total_h.append(np.array([h1-10, h2-10]))
        total_h = np.array(total_h)
        total_k = total_h

        # Start to find possible (h,k)
        for h in total_h:
            for k in total_k:
                p_hk = np.array([h,k])

                # Filter 1: All A: (h,k) must be positive definite
                if not np.all(np.linalg.eigvals(p_hk + p_hk.T)> 0):
                    continue

                # Filter 2: |h x k| ∈ [4,16]
                # target system range from (2x2) to (4x4)
                mo_hk = np.cross(h, k)
                if mo_hk < self.start_A or mo_hk > self.end_A:
                    continue

                # generate u', v'
                uv_dot = np.dot(p_hk, uv)
                u_dot, v_dot = uv_dot

                # Filter 3: |u'| >= |v'| and |u'| < 3|v'|
                # |u'| >= |v'| reduce computational costs
                # 3|u'| < |v'| filters too narrow supercell
                if norm(u_dot) < norm(v_dot) or norm(u_dot) >= 3 * norm(v_dot):
                    continue
                
                # Filter 4: angle between u', v' ∈ [60°, 90°]
                # kept as the valid/non-redundant supercell candidate
                cos_theta = np.dot(u_dot,v_dot)/(norm(u_dot)*norm(v_dot))
                if cos_theta < 0 or cos_theta > 0.5:
                    continue

                # Filter 5: |h|, |k| not repeated
                norm_u = np.round(norm(h), 3)
                norm_v = np.round(norm(k), 3)
                if (norm_u, norm_v) in norm_hk_list:
                    print((norm_u, norm_v))
                    continue
                
                A_list.append(mo_hk)
                possible_hk.append(p_hk)
                possible_grids.append(uv_dot)
                norm_hk_list.append((norm_u, norm_v))
        
        possible_hk, possible_grids = self.rearrange(possible_hk, possible_grids, A_list)
        return possible_hk, possible_grids, A_list
    
    def rearrange(self, 
                  possible_hk:List, 
                  possible_grids:List,
                  A_list:List) -> np.asarray:
        hk_list = []
        grid_list = []
        
        for target_A in range(self.end_A - self.start_A + 1):
            target_A += self.start_A
            for i in range(len(A_list)):
                A = A_list[i]
                if A == target_A:
                    hk_list.append(possible_hk[i])
                    grid_list.append(possible_grids[i])

        return np.array(hk_list), np.array(grid_list)

    def distance(self, x1: np.asarray, x2:np.asarray) -> float:
        return norm(x1 - x2)

    def empty_sites(self, atoms:Atoms) -> np.asarray:
        surf_atoms = self.env.get_surf_list(atoms)
        sub_sites = self.in_cell_sites(atoms, site_type='sub')

        empty_sites = []

        # print(f"The surf atoms are {surf_atoms}")
        if not surf_atoms:
            # Sub layer is empty
            empty_sites = sub_sites
        else:
            for sub_site in sub_sites:
                to_other_ele_dis_1 = []
                for atom_idx in surf_atoms:
                    distance = self.distance(atoms.get_positions()[atom_idx], 
                                             sub_site[0:3] + np.array([0, 0, self.env.d_list[int(sub_site[3]) - 1 ]]))
                    to_other_ele_dis_1.append(distance)

                if min(to_other_ele_dis_1) >= 1.5:
                    empty_sites.append(sub_site)
            # All sub layer sites has been occupied
            if not empty_sites:
                surf_sites = self.in_cell_sites(atoms, site_type='surf')
                layer_atoms = self.env.get_layer_list(atoms)
                if layer_atoms:
                    for surf_site in surf_sites:
                        to_other_ele_dis_2 = []
                        for atom_idx in layer_atoms:
                            distance = self.distance(atoms.get_positions()[atom_idx], 
                                                     surf_site[0:3]+ np.array([0, 0, self.env.d_list[int(surf_site[3]) - 1 ]]))
                            to_other_ele_dis_2.append(distance)
                        if min(to_other_ele_dis_2) >= 1.5:
                            empty_sites.append(surf_site)
                else:
                    empty_sites = surf_sites
            # print(empty_sites)
        return empty_sites

    def choose_ads_site(self,atoms:Atoms, n_Ag:int, n_O:int) -> Atoms:
        new_state = atoms.copy()
        self.forbidden_site = []
        for _ in range(n_Ag):
            empty_sites = self.empty_sites(new_state)
            Ag_site = empty_sites[np.random.randint(len(empty_sites))]
            # print(Ag_site)
            Ag = Atom('Ag', (Ag_site[0], 
                             Ag_site[1], 
                             Ag_site[2] + self.env.d_list[int(Ag_site[3]) - 1 ] * 1.5))
            new_state += Ag
            self.forbidden_site.append(Ag_site.tolist())

        for _ in range(n_O):
            empty_sites = self.empty_sites(new_state)
            O_site = empty_sites[np.random.randint(len(empty_sites))]
            # print(O_site)
            O = Atom('O', (O_site[0], 
                           O_site[1], 
                           O_site[2] + self.env.d_list[int(O_site[3]) - 1 ]))
            new_state += O
            self.forbidden_site.append(O_site.tolist())

        self.forbidden_site = []
        return new_state
    
    def add_mole(self, mole:str, d:Optional[float] = None) -> float:
        new_state = self.initial_slab.copy()
        energy_1 = self.calculator(new_state, calc_type = 'single')
        if len(mole) == 1:
            ele = Atom(mole[0], (new_state.get_cell()[0][0] / 2, 
                              new_state.get_cell()[1][1] / 2, 
                              new_state.get_cell()[2][2] - 5.0))
            new_state += ele
        if len(mole) == 2:
            ele_1 = Atom(mole[0], (new_state.get_cell()[0][0] / 2,
                                   new_state.get_cell()[1][1] / 2, 
                                   new_state.get_cell()[2][2] - 5.0))
            ele_2 = Atom(mole[1], (new_state.get_cell()[0][0] / 2, 
                                   new_state.get_cell()[1][1] / 2, 
                                   new_state.get_cell()[2][2] - 5.0 + d))
            new_state += ele_1
            new_state += ele_2
        energy_2 = self.calculator(new_state, calc_type = 'single')
        energy = energy_2 - energy_1
        return energy
    
    def pd(self, atoms:Atoms) -> np.asarray:
        pad =  torch.nn.ZeroPad2d(padding = (0,0,0, 200 - len(atoms.get_scaled_positions())))
        return np.array(pad(torch.tensor(atoms.get_positions())))
    
    def miu(self, 
            current_energy:float, 
            initial_energy:float, 
            n_Ag: int, 
            n_O: int,
            A:int) -> float:
        current_energy -= self.E_Ag * n_Ag + self.E_O * n_O
        miu = (current_energy - initial_energy) / A
        return miu
    
    def judge_structure(self, atoms):
        positions = atoms.get_positions().tolist()
        return [atom_idx for atom_idx, position in enumerate(positions) \
                if position in positions[:atom_idx]]
    
    @timeout_decorator.timeout(60)
    def initial_energy(self, atoms):
        self.env.to_constraint(atoms)
        atoms, initial_energy, _ = self.calculator(atoms)
        return atoms, initial_energy
    
    def postprocessing(self):
        # This part is for the  Step 3: Favorable composition determination
        # by Monte Carlo selection
        pass

if __name__ == '__main__':
    initial_slab = fcc110('Ag', size=(20, 20, 4), vacuum=10.0)
    mock_slab = fcc110('Ag', size = (1,1,4), vacuum = 10.0)
    asop = ASOP(initial_slab = initial_slab,
                mock_slab=mock_slab,
                calculator_method = 'LASP',
                model_path = 'AgO')
    asop.run()